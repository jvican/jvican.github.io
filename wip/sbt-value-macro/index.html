    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="Jorge Vicente Cantero">
		
		<meta name="generator" content="Hugo 0.19" />
		<title>The semantics of value in sbt &middot; jvican</title>
		<link rel="shortcut icon" href="https://jvican.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://jvican.github.io/css/style.css">
		<link rel="stylesheet" href="https://jvican.github.io/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://jvican.github.io/css/monosocialiconsfont.css">
		

		
		<link href="https://jvican.github.io/index.xml" rel="alternate" type="application/rss+xml" title="jvican" />
		

		<meta property="og:title" content="The semantics of value in sbt" />
<meta property="og:description" content="The sbt value macro is one of the most misleading features of sbt. In the surface, it&rsquo;s a great invention. But once you realize how it works it can bite you more often than expected.
Sbt users are usually not familiar with the semantics of value even though they are nicely explained in the official documentation. What the documentation skips, though, is why it is the way it is and what we can do to we face its limitations." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jvican.github.io/post/sbt-value-macro/" />



<meta property="article:published_time" content="2017-03-29T19:05:17&#43;02:00"/>
<meta property="article:modified_time" content="2017-03-29T19:05:17&#43;02:00"/>











	    
	    
<meta itemprop="name" content="The semantics of value in sbt">
<meta itemprop="description" content="The sbt value macro is one of the most misleading features of sbt. In the surface, it&rsquo;s a great invention. But once you realize how it works it can bite you more often than expected.
Sbt users are usually not familiar with the semantics of value even though they are nicely explained in the official documentation. What the documentation skips, though, is why it is the way it is and what we can do to we face its limitations.">


<meta itemprop="dateModified" content="2017-03-29T19:05:17&#43;02:00" />
<meta itemprop="wordCount" content="756">



<meta itemprop="keywords" content="" />

	    

  <meta name="twitter:card" content="summary"/>



<meta name="twitter:text:title" content="The semantics of value in sbt"/>
<meta name="twitter:title" content="The semantics of value in sbt"/>
<meta name="twitter:description" content="The sbt value macro is one of the most misleading features of sbt. In the surface, it&rsquo;s a great invention. But once you realize how it works it can bite you more often than expected.
Sbt users are usually not familiar with the semantics of value even though they are nicely explained in the official documentation. What the documentation skips, though, is why it is the way it is and what we can do to we face its limitations."/>
<meta name="twitter:site" content="@https://www.twitter.com/jvican"/>

	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://jvican.github.io/'> <span class="arrow">←</span>Home</a>
	

	
		<a href='https://jvican.github.io/about'>About me</a>
	

	
	<a class="cta" href="https://jvican.github.io/index.xml">Subscribe</a>
	
</nav>

        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>The semantics of value in sbt</h1>
                    <h2 class="headline">
                    March 29, 2017 
                    <br>
                    
                    </h2>
                </header>
                <section id="post-body">
                    

<p>The sbt <code>value</code> macro is one of the most misleading features of sbt. In the
surface, it&rsquo;s a great invention. But once you realize how it works it can bite
you more often than expected.</p>

<p>Sbt users are usually not familiar with the semantics of <code>value</code> even though
they are nicely explained <a href="http://www.scala-sbt.org/0.13/docs/Task-Graph.html">in the official
documentation</a>.  What the
documentation skips, though, is why it is the way it is and what we can do to we
face its limitations. Below I dive into these aspects, I illustrate why you
should be weary of its use and give you some tips to avoid surprises.</p>

<h2 id="what-does-value-do">What does <code>value</code> do?</h2>

<p>The <code>value</code> macro is the main component of the sbt DSL. It allows you to get the
value of any task and setting of your build. It provides to users:</p>

<ol>
<li>A way to abstract over the internal sbt API.</li>
<li>An easy-to-use construct for a common operation.

<br />
<br /></li>
</ol>

<p>For example, let&rsquo;s define a task in our <code>build.sbt</code>:</p>

<pre><code class="language-scala">lazy val myCompileTask = taskKey[Unit](&quot;Compile.&quot;)
</code></pre>

<p>And let&rsquo;s <em>implement</em> it:</p>

<pre><code class="language-scala">myCompileTask := {
  compile.value
}
</code></pre>

<p>As you see, <code>myCompileTask</code> is an alias for <code>compile</code>. The interesting bit of
this code is how <code>compile.value</code> is expanded by the macro:</p>

<pre><code class="language-scala">myCompileTask := {
  compile.map { compilationResult =&gt;
    // Nothing here, we do nothing with the result
    ()
  }
}
</code></pre>

<p>At a first glance, the <code>value</code> macro takes care of:</p>

<ol>
<li>Getting all the identifiers wrapped by <code>value</code>s in a block and
registering them as dependencies of <code>myCompileTask</code>.</li>
<li>Mapping this dependency to the internal sbt API, which is monadic.
<br />
<br /></li>
</ol>

<p>One may expect this transformation to be powerful. So you may be bold and
implement a fancier compile task that is only run by the CI.</p>

<pre><code class="language-scala">lazy val runOnCI = taskKey[Unit](&quot;Compile on the CI&quot;)
runOnCI := {
  val logger = streams.value.log
  val ci = sys.env.get(&quot;DRONE&quot;)
  if (ci.map(_.toBoolean).isDefined) {
    logger.info(&quot;Running compile on CI.&quot;)
    compile.value
  }
}
</code></pre>

<p>However, when you run <code>runOnCI</code> locally, you will be surprised to see that
<code>compile</code> is being called even if you guarded its execution with an if
expression and its condition predicate is not met.</p>

<p>What&rsquo;s happened? We&rsquo;ve forgotten we&rsquo;re writing sbt, not Scala code.</p>

<h2 id="a-closer-look-to-the-semantics">A closer look to the semantics</h2>

<p>Some may argue that this is a feature of sbt. If you think about sbt being a
graph, it makes sense that dependent nodes are visited before the node (task)
you have defined.</p>

<p>However, I don&rsquo;t think it&rsquo;s a feature. I think that the current semantics are
just a leak of the underlying implementation.</p>

<p>The <code>value</code> macro has fundamental limitations to imitate Scala semantics because
providing generic code transformations that respect them is difficult and not
trivial. What <code>value</code> essentially does is to lift sbt code into Scala code, but
it does not promise a one-to-one mapping between the two.</p>

<p>Let&rsquo;s have a closer look at the expanded code. The previous task implementation
is equivalent to:</p>

<pre><code class="language-scala">runOnCI := {
  (streams, compile).map { (st, compilationResult) =&gt;
    val logger = st.log
    val ci = sys.env.get(&quot;DRONE&quot;)
    if (ci.map(_.toBoolean).isDefined) {
      logger.info(&quot;Running compile on CI.&quot;)
      compilationResult
    }
  }
}
</code></pre>

<p>While what we actually want is:</p>

<pre><code class="language-scala">runOnCI := {
  streams.map { st =&gt;
    val logger = st.log
    val ci = sys.env.get(&quot;DRONE&quot;)
    if (ci.map(_.toBoolean).isDefined) {
      logger.info(&quot;Running compile on CI.&quot;)
      compile.map { compilationResult =&gt;
        ()
      }
    }
  }
}
</code></pre>

<p>Why can&rsquo;t sbt be smarter enough to expand the initial task into that code?</p>

<p>I can think of three reasons:</p>

<ol>
<li>The macro code to handle all the corner cases (if and while expressions,
pattern matching, by-name parameters, lazy vals, closures, top-level
expressions in classes, etc) grows larger and more complex.</li>
<li>Providing a correct implementation is hard and likely to have bugs.</li>
<li>Macros were a young project when sbt started to use them. Back in the day,
the macro API and the infrastructure around it were not as <em>mature</em> as they are
now.
<br />
<br /></li>
</ol>

<p>I cannot blame sbt maintainers by constraining the semantics of the sbt DSL.
This is not an easy problem.  Shipping complex, <em>untested</em> macro code into a
production-ready build tool doesn&rsquo;t seem a good idea.</p>

<p>However, I think the current implementation creates confusion for sbt users and
makes learning sbt one of the hardest things when starting in Scala.</p>

<p>To work around the described problem, sbt started to build in artificial
constructs that allow users to emulate Scala semantics manually. For example,
dynamic tasks are supposed to be the right way to work around this problem in
idiomatic sbt. This was all done in the spirit of simplifying sbt, but I believe
it ended up backfiring the original purpose of the sbt DSL.</p>

                </section>
            </article>
            <footer id="post-meta" class="clearfix">
                <a href="https://twitter.com/jvican">
                        <img class="avatar" src="https://jvican.github.io/images/avatar.png">
                        <div>
                            <span class="dark">Jorge Vicente Cantero</span>
                            <span>I hack on Scala.</span>
                        </div>
                    </a>
                <section id="sharing">
                    <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fjvican.github.io%2fpost%2fsbt-value-macro%2f - The%20semantics%20of%20value%20in%20sbt by @jvican"><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

                </section>
            </footer>

            

            <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        
        <li>
            <a href="https://jvican.github.io/post/sbt-value-macro/">The semantics of value in sbt<aside class="dates">Mar 29</aside></a>
        </li>
        
   
    
        
        <li>
            <a href="https://jvican.github.io/post/introduction/">Informal introduction<aside class="dates">Mar 27</aside></a>
        </li>
        
   
</ul>

            <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://www.github.com/jvican">
        circlegithub
    </a>
    
    <a class="symbol" href="https://www.twitter.com/jvican">
        circletwitterbird
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2017 Jorge Vicente Cantero
    
    </p>
</footer>

        </section>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://jvican.github.io/js/main.js"></script>
<script src="https://jvican.github.io/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





    </body>
</html>
