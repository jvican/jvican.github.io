    <!DOCTYPE html>
<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<meta name="author" content="Jorge Vicente Cantero">
		
		<meta name="generator" content="Hugo 0.49" />
		<title>Overload methods with extra parameter lists &middot; jvican</title>
		<link rel="shortcut icon" href="https://jvican.github.io/images/favicon.ico">
		<link rel="stylesheet" href="https://jvican.github.io/css/style.css">
		<link rel="stylesheet" href="https://jvican.github.io/css/highlight.css">
		

		
		<link rel="stylesheet" href="https://jvican.github.io/css/monosocialiconsfont.css">
		

		
		<link href="https://jvican.github.io/index.xml" rel="alternate" type="application/rss+xml" title="jvican" />
		

		<meta property="og:title" content="Overload methods with extra parameter lists" />
<meta property="og:description" content="A technique to shadow and overload a method with extra parameter lists." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jvican.github.io/post/implicit-parameter-overload/" /><meta property="article:published_time" content="2018-10-25T20:29:12&#43;02:00"/>
<meta property="article:modified_time" content="2018-10-25T20:29:12&#43;02:00"/>

	    
	    
<meta itemprop="name" content="Overload methods with extra parameter lists">
<meta itemprop="description" content="A technique to shadow and overload a method with extra parameter lists.">


<meta itemprop="datePublished" content="2018-10-25T20:29:12&#43;02:00" />
<meta itemprop="dateModified" content="2018-10-25T20:29:12&#43;02:00" />
<meta itemprop="wordCount" content="1576">



<meta itemprop="keywords" content="" />

	    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Overload methods with extra parameter lists"/>
<meta name="twitter:description" content="A technique to shadow and overload a method with extra parameter lists."/>
<meta name="twitter:site" content="@https://www.twitter.com/jvican"/>

	</head>

    <body>
       <nav class="main-nav">
	
	
		<a href='https://jvican.github.io/'> <span class="arrow">←</span>Home</a>
	

	
		<a href='https://jvican.github.io/about'>About me</a>
	

	
	<a class="cta" href="https://jvican.github.io/index.xml">Subscribe</a>
	
</nav>

        <section id="wrapper">
            <article class="post">
                <header>
                    <h1>Overload methods with extra parameter lists</h1>
                    <h2 class="headline">
                    October 25, 2018 
                    <br>
                    
                    </h2>
                </header>
                <section id="post-body">
                    

<p>Have you ever asked yourself if you can enrich a method that you need to
implement in a class to receive more information from the call site?</p>

<p>For example, let&rsquo;s say you have method <code>debug</code> in a logger interface <code>AbstractLogger</code>.
Can we implement the logger interface and at the same time overload <code>debug</code>
with another version that takes more parameters every time the users of our API
call <code>debug</code>?</p>

<p>In fact, can we do this without breaking binary compatibility in the interface
that defines <code>debug</code> and ensuring that the users of our API can only call the
enriched method?</p>

<p>I asked myself this question three days ago and I came up with a solution that
I think it&rsquo;s worth a short explanation in this blog post. My use case was
triggered by <a href="https://github.com/scalacenter/bloop/issues/333">a feature I wanted to add</a> to <a href="https://github.com/scalacenter/bloop">bloop</a> (a fast compilation
server for Scala).</p>

<h2 id="what-is-the-problem">What is the Problem?</h2>

<p>It&rsquo;s always amazed me how verbose the debug log level can be under tools such
as sbt. This verbosity typically stands in the way of finding the cause for
a resolution or compilation misbehavior. Running <code>debug</code> on the sbt shell would
dump more than 20.000 logs in my screen, enough to overflow my terminal buffer
and lose potentially important debug logs on the way.</p>

<p>I&rsquo;ve found myself often in this scenario. It feels like you&rsquo;re trying to find
a needle in a haystack. It can be better if you&rsquo;re lucky enough to know the
shape of the debug messages you&rsquo;re after (you can grep), but this is rarely the
case.</p>

<p>I wanted bloop users to have a better time debugging a compilation or testing
issues by narrowing down the scope of the debug logs with filters. <code>bloop test
my-app --debug test</code> would only dump debug logs related to the test task,
instead of all the other debug messages in unrelated tasks.</p>

<p>The logging infrastructure in <a href="https://github.com/scalacenter/bloop">bloop</a> implements several third-party <code>Logger</code>
interfaces and aggregates them in an abstract class <code>BloopLogger</code> (for
simplicity we&rsquo;ll extend only one: <code>AbstractLogger</code>).</p>

<pre><code class="language-scala">// A third-party logger interface (in our classpath)
abstract class AbstractLogger {
  def debug(msg: String): Unit
  def info(msg: String): Unit
  def error(msg: String): Unit
}

// The logger interface that we use in all the bloop APIs
abstract class BloopLogger extends AbstractLogger

// One simple implementation of a bloop logger
class SimpleLogger extends BloopLogger {
  override def debug(msg: String): Unit = println(s&quot;Debug: $msg&quot;)
  override def info(msg: String): Unit = println(s&quot;Info: $msg&quot;)
  override def error(msg: String): Unit = println(s&quot;Error: $msg&quot;)
}
</code></pre>

<p>(Scastie link to runnable code <a href="https://scastie.scala-lang.org/gqI3gCsVTJuGWCeoZrpuHg">here</a>.)</p>

<p>We&rsquo;d like to add an enriched version of <code>debug</code> that looks like <code>debug(msg:
String)(implicit ctx: DebugContext)</code>, where <code>DebugContext</code> identifies the
context where <code>debug</code> is called. (We decide to make the parameter implicit, but
there&rsquo;s no reason why you shouldn&rsquo;t be able to make it explicit.)</p>

<p>Third-party logging APIs are frozen and cannot be modified, so we cannot change
the original <code>debug</code> method signature in <code>AbstractLogger</code>.</p>

<p>Besides, we don&rsquo;t want to add an special method <code>debugWithFilter</code> that we would
need to teach to all Bloop project contributors. We would spend a lot of time
telling contributors that they must not use the normal <code>debug</code>, but
<code>debugWithFilter</code> because bla.</p>

<p>What we really want is to <strong>shadow the original <code>debug</code> method</strong> with the
&ldquo;enriched&rdquo; <code>debug</code> method so that only the latter can be used by default.</p>

<p>So, wrapping up, we don&rsquo;t only want to overload a method, but also shadow it,
and we want to do that without changing the public API of the interfaces we
implement. It looks hard but let&rsquo;s persevere.</p>

<p>How do we go about implementing this feature?</p>

<h2 id="a-first-approach">A First Approach</h2>

<p>We know beforehand the compiler will tell us there&rsquo;s some kind of ambiguity
between the two <code>debug</code> methods, but bear with me and let&rsquo;s write the simplest
possible solution: let&rsquo;s add the new <code>debug</code> method in <code>SimpleLogger</code> and then
use it in a small <code>main</code> method.</p>

<pre><code class="language-scala">// The debug context that we want to pass implicitly
sealed trait DebugContext
object DebugContext {
  case object Ctx1 extends DebugContext
  case object Ctx2 extends DebugContext
}

// The logger interface that we use in all the bloop APIs
abstract class BloopLogger extends AbstractLogger {
  def debug(msg: String)(implicit ctx: DebugContext): Unit
}

// One simple implementation of a bloop logger
final class SimpleLogger extends BloopLogger {
  override def debug(msg: String): Unit = println(s&quot;Debug: $msg&quot;)
  override def info(msg: String): Unit = println(s&quot;Info: $msg&quot;)
  override def error(msg: String): Unit = println(s&quot;Error: $msg&quot;)

  override def debug(msg: String)(implicit ctx: DebugContext): Unit =
    println(s&quot;Debug: $msg&quot;)
}

// The application that is the use site of our logger API
object MyApp {
  def main(args: Array[String]): Unit = {
    val logger = new SimpleLogger
    logger.debug(&quot;This is a debug message&quot;)
  }
}
</code></pre>

<p>When we compile the above code, the compiler emits the following error:</p>

<pre><code>ambiguous reference to overloaded definition,
  both method debug in class SimpleLogger of type (msg: String)(implicit ctx: DebugContext)Unit
  and  method debug in class SimpleLogger of type (msg: String)Unit
  match argument types (String)
</code></pre>

<p>(Scastie link to runnable code <a href="https://scastie.scala-lang.org/R4bck5yoR4SJ0kjnIppJHw">here</a>.)</p>

<p>Can we work around this ambiguous reference? Let&rsquo;s consider all our
possibilities.</p>

<p>If we try to change the call-site to select the most specific debug method
(<code>logger.debug(&quot;This is a debug message&quot;)(DebugContext.Ctx1)</code>), the error
persists.</p>

<p>If we try to move the new debug definition to the implementation class, then it
won&rsquo;t be usable by APIs using <code>BloopLogger</code>, which the rest of our codebase
does because we have several implementations.</p>

<p>It looks like everything is lost. But this is the moment when knowing or
intuiting that the ambiguity checker inside the compiler relies on the
linearization order saves your day.</p>

<h2 id="a-solution-that-relies-on-class-linearization">A Solution that Relies on Class Linearization</h2>

<p>First off, what&rsquo;s the linearization order? There are a few good resources in
Internet, such as <a href="http://ktoso.github.io/scala-types-of-types/#type-linearization-vs-the-diamond-problem">this one</a>, that explain it well.
But let me oversimplify and say that you can think of the linearization order
as the order with which Scala will initialize an instance of a given class and
all its super classes (or traits).</p>

<p>When Scala looks up the definition of a member, it relies on the linearization
order to pick the first unambiguous candidate. A quick example:</p>

<pre><code class="language-scala">trait A
trait B extends A { def foo: String }
trait C
class D extends C with B

// The linearization order to find `foo` is `D -&gt; C -&gt; B`
(new D).foo
</code></pre>

<p>The same procedure happens when Scala checks for ambiguous references and emits
errors such as the ones we got before. As this example illustrates, the
compiler will not exhaustively look for definitions of <code>foo</code> in all transitive
super classes, it stops at the first search hit.</p>

<p>This insight means that we can modify our previous example such that our
enriched <code>debug</code> method is always found first. This way, we dodge the ambiguous
reference to overloaded <code>debug</code>s.</p>

<pre><code class="language-scala">// We make `DebugLogger` private at the logging package level to avoid undesired users
private[logging] abstract class DebugLogger extends AbstractLogger {
  protected def printDebug(msg: String): Unit
  override def debug(msg: String): Unit = printDebug(msg)
}

// The logger interface that we use in all the bloop APIs
abstract class BloopLogger extends DebugLogger {
  def debug(msg: String)(implicit ctx: DebugContext): Unit
}

// One simple implementation of a bloop logger
final class SimpleLogger extends BloopLogger {
  override def info(msg: String): Unit = println(s&quot;Info: $msg&quot;)
  override def error(msg: String): Unit = println(s&quot;Error: $msg&quot;)
  override protected def printDebug(msg: String): Unit =
    println(s&quot;Debug: $msg&quot;)
  override def debug(msg: String)(implicit ctx: DebugContext): Unit =
    printDebug(s&quot;$msg ($ctx)&quot;)
}
</code></pre>

<p>The trick to make the previous code work is defining the implementation of the
simple <code>debug</code> method in <code>DebugLogger</code> and making <code>BloopLogger</code> extend
<code>DebugLogger</code>. We have introduced a <code>printDebug</code> to avoid inter-dependencies
between the two <code>debug</code> methods, as they will cause other reference errors.</p>

<p>Once we have defined the method we want to shadow in a super class of the class
we want to support in our API (in this case <code>BloopLogger</code>), the logger
implementations only need to define the enriched <code>debug</code> method.</p>

<p>Users of this API <strong>will not</strong> be able to call the simple <code>debug</code> <strong>unless</strong>
they do an upcast to the third-party logger <code>Logger</code>. This is intended &ndash; the
goal is to have a good default, not to make it completely impossible to call
the simple debug, so make sure that it still has a sensible implementation.</p>

<p>In Bloop&rsquo;s case, the third-party logger API is never exposed and I recommend
doing so in your application or library if you can.</p>

<p>With the above code, compiling our simple <code>MyApp</code> fails compilation with
a <code>could not find implicit value for parameter ctx: DebugContext</code>, which
confirms us that Scala is successfully selecting the right method.</p>

<p>We can fix it by passing the context either implicitly or explicitly.</p>

<pre><code class="language-scala">object MyApp {
  def main(args: Array[String]): Unit = {
    println(
      &quot;Running demo application for https://jorge.vican.me/post/implicit-parameter-overload/&quot;)
    implicit val ctx: DebugContext = DebugContext.Ctx1
    val logger = new SimpleLogger
    logger.debug(&quot;This is a debug message&quot;)
  }
}
</code></pre>

<h3 id="complete-scastie-example">Complete Scastie Example</h3>

<p>Let&rsquo;s double-check it with Scastie.</p>

<script src="https://scastie.scala-lang.org/D4cAr7CLT3u29CVDI5ddoA.js"></script>

<h2 id="conclusion">Conclusion</h2>

<p>Overloading a method inherited from a third-party class is possible in Scala.
It requires a little bit of gymnastics, but once we&rsquo;re familiar with the
technique we can apply it in many other scenarios.</p>

<p>The same technique works with new explicit parameters (instead of implicit
parameters). They key point is that we can overload methods by adding extra
parameter lists to their definition, playing with the linearization order and
defining the methods in the right place.</p>

<style type="text/css">
.scastie.embedded {
  width: 100% !important;
}
.output-console {
  height: 150px !important;
  font-size: 14px !important;
}
</style>

                </section>
            </article>
            <footer id="post-meta" class="clearfix">
                <a href="https://twitter.com/jvican">
                        <img class="avatar" src="https://jvican.github.io/images/avatar.png">
                        <div>
                            <span class="dark">Jorge Vicente Cantero</span>
                            <span>I hack on Scala and devtools.</span>
                        </div>
                    </a>
                <section id="sharing">
                    <a class="twitter" href="https://twitter.com/intent/tweet?text=https%3a%2f%2fjvican.github.io%2fpost%2fimplicit-parameter-overload%2f - Overload%20methods%20with%20extra%20parameter%20lists by @jvican"><span class="icon-twitter"> Tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

                </section>
            </footer>

            

            <ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        
        <li>
            <a href="https://jvican.github.io/post/implicit-parameter-overload/">Overload methods with extra parameter lists<aside class="dates">Oct 25</aside></a>
        </li>
        
   
    
        
        <li>
            <a href="https://jvican.github.io/post/scalac-profiling/">Profiling and reducing compile times of typeclass derivation<aside class="dates">May 20</aside></a>
        </li>
        
   
    
        
        <li>
            <a href="https://jvican.github.io/post/git-sbt-analysis/">How often do we change our sbt builds<aside class="dates">Oct 19</aside></a>
        </li>
        
   
    
        
        <li>
            <a href="https://jvican.github.io/post/introduction/">Informal introduction<aside class="dates">Mar 27</aside></a>
        </li>
        
   
</ul>

            <footer id="footer">
    
        <div id="social">

	
	
    
    <a class="symbol" href="https://www.github.com/jvican">
        circlegithub
    </a>
    
    <a class="symbol" href="https://www.twitter.com/jvican">
        circletwitterbird
    </a>
    


</div>

    
    <p class="small">
    
        © Copyright 2018 Jorge Vicente Cantero
    
    </p>
</footer>

        </section>

        <script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script src="https://jvican.github.io/js/main.js"></script>
<script src="https://jvican.github.io/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





    </body>
</html>
